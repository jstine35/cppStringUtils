#!/bin/bash

shopt -s globstar nullglob

vcxproj_filename=$1
infiles=$*

outfile=${GEN_OUTPUT_TO:-${vcxproj_filename}.filters}

# hmm, could do a wildcard search for _any_ files in the whole project with spaces.

if egrep '\<(ClInclude|ClCompile|FxCompile|None)  *Include *= *' $infiles | cut -d '"' -f2 | grep ' '; then
	>&2 echo "Error : spaces are not allowed in our build system!"
	exit 1
fi

includes=$(egrep  '\<[a-zA-Z_][a-zA-Z0-9_]* *Include *= *\"' $infiles | grep -v "ProjectConfiguration ")

ItemGroups=$(cut -d '<' -f 2 <<< "$includes" | cut -d ' ' -f1 | sort | uniq)

echo '<?xml version="1.0" encoding="utf-8"?>
<!-- Machine-generated by UpdateProjectSrcs.sh - DO NOT MODIFY BY HAND OR WITH VISUAL STUDIO -->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
' > $outfile

uniq_folders=

GenClSection() {
	xmltag=$1
	shift
	
	allfiles=$(grep "$xmltag " <<< "$includes" | cut -d '"' -f2)
	allfiles_fws=$(tr '\\' '/' <<< "$allfiles")
	
	if [[ -z "$allfiles" ]]; then
		return
	fi
	
	# todo: can handle more gracefully nested dirs?  Currently just take the leftmost two dirs.
	alldirs=$(dirname $allfiles | cut -d'/' -f1-2)

	# use paste as optimization, since calling dirname/cut inside the for loop is too slow.
	VAR3=$(paste <(printf "%s\n" $allfiles) <(printf "%s\n" $allfiles_fws) <(printf "%s\n" $alldirs))

	echo '  <ItemGroup>'
	while read -r filename filename_fws dirname_fws; do
		>/dev/tty echo "Processing item: $filename_fws"
		
        # handle files that are rooted in top-level dir(s), for now just root them in extroot.
		if [[ $filename_fws == ../* || $filename_fws == /* ]]; then
			folder=extroot
		else
			folder=$dirname_fws
			
			if [[ $folder == ./* || $folder == ../* || $folder == /* ]]; then
				# fallback if somehow the above results in poop...
				folder=$(basename $(dirname "$filename_fws"))
			fi
		fi

        folder=${folder#src/}

		# failsafe - give up and just top-level it...
		if [[ $folder == . || $folder == ./* || $folder == ../* || $folder == /* ]]; then
			folder=
		fi

		if [[ -n "$folder" && "$folder" != src ]]; then
			uniq_folders+=$(tr '/' '\\' <<< "$folder")
			uniq_folders+=$'\n'

			printf "    <$xmltag Include=\"%s\">\n"      $filename     
			printf "      <Filter>%s</Filter>\n"         $folder
			printf "    </$xmltag>\n"						
		else
			printf "    <$xmltag Include=\"%s\" />\n"    $filename
		fi
	done <<< "$VAR3"

	echo '  </ItemGroup>'
}

rndchar() {
	for i in $(seq 1 $1); do
		echo $(( $RANDOM % 16 ))
	done
}

MakeUuid()
{
    # use random number seed based on filter string name
    # this avoids UUIDs changing every time we re-run the script.
    # TODO: could sha256 digest the input string and then take first 30 chars?

    RANDOM=$(printf "%d" 0x$(openssl dgst <<< "$1" | cut -c10-13))

	printf "%x"   $(rndchar  8); printf '-'
	printf "%x"   $(rndchar  4); printf '-'
	printf "%x"   $(rndchar  4); printf '-'
	printf "%x"   $(rndchar  4); printf '-'
	printf "%x"   $(rndchar 10); printf '\n'
}

GenUuidSection() {
	echo '  <ItemGroup>'
	#uniq_folders=$(basename --multiple $(dirname $includes $compiles $fxcomps $noneincs) | sort -u)
	
	for i in $(echo "$uniq_folders" | sort -u); do
        fixed=$(tr '\\' '/' <<< "$i")
		echo "    <Filter Include=\"$fixed\">"
		echo "      <UniqueIdentifier>$(MakeUuid "$fixed")</UniqueIdentifier>"
		echo "    </Filter>"
	done
	echo "  </ItemGroup>"
}

for item in $ItemGroups; do
	echo "Generating Section '$item'"; GenClSection $item >> $outfile
done

echo "Generating Section 'UniqueIdentifier'"; GenUuidSection >> $outfile

echo '</Project>' >> $outfile

# tells visual studio to reload things...
touch $vcxproj_filename

